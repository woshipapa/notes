# **指令**

操作码+地址码

### 根据地址码的个数分为：

1.零地址指令：

不需要地址码，只需要操作，相当于void参数的操作，停机，关中断，或者操作数在栈中，直接出栈的操作。

地址码指的是主存的地址，还需要根据地址取出内容

2.一地址指令

注意俩个操作数时，可能有一个操作数已经存在CPU的寄存器中了。

![image-20230513162423085](C:\Users\papa\AppData\Roaming\Typora\typora-user-images\image-20230513162423085.png)

3.二地址指令

完成操作后，将结果放回其中一个地址中。



4.三地址指令

与二地址指令不同，将结果放到一个**指定的地址**中。

![image-20230513163746042](C:\Users\papa\AppData\Roaming\Typora\typora-user-images\image-20230513163746042.png)

5.四地址指令

还会指定PC指向某个地址去取指执行，跳跃式。

![image-20230513163817781](C:\Users\papa\AppData\Roaming\Typora\typora-user-images\image-20230513163817781.png)

当然地址码数量越多，能表示的地址越少，寻址能力越差。

#### 根据指令长度分类

![image-20230513164151648](C:\Users\papa\AppData\Roaming\Typora\typora-user-images\image-20230513164151648.png)

#### 根据操作类型分

数据传送（主存与CPU，CPU与IO端口）

运算（逻辑运算，算术运算）

程序控制类

![image-20230513165051909](C:\Users\papa\AppData\Roaming\Typora\typora-user-images\image-20230513165051909.png)

#### 根据操作码长度分

操作码长度定长和不定长。



对于不同数目的地址码，操作码长度也会变。

可变长操作码，根据操作码的状态可以识别是几地址指令

但要注意设计编码时，短码不能是长码的前缀，否者会译码歧义。



**![image-20230513173633483](C:\Users\papa\AppData\Roaming\Typora\typora-user-images\image-20230513173633483.png)**



PC程序计数器------记录了下一条将要执行的指令在主存中的位置。

PC+多少取决于这条指令的指令字长，以及主存如何编址（按字节，按字长）

指令字长要考虑到固定的和可变的。

可变的指令字长的指令，CPU会根据操作码的长度来判断是几地址指令从而判断指令字长。

每取走一条指令，就让PC+**“1”**,然后CPU执行当前指令。

注意：“1”是指令字长可能不一样的。

跳跃寻址是因为一些程序控制类的指令而跳转的，但是PC也是先加1之后才被重新赋值的。